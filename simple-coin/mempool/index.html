<!DOCTYPE html><html lang="ko" class="__className_fde3a9 size-full"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/2e677674121e02c0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-2d2dc68beef0c482.js"/><script src="/_next/static/chunks/80433fe4-e24eaad93a1cfb9d.js" async=""></script><script src="/_next/static/chunks/367-0ec4dc94cb811371.js" async=""></script><script src="/_next/static/chunks/main-app-f1b4d9826ef8e891.js" async=""></script><script src="/_next/static/chunks/dd507964-94e7a1153960be03.js" async=""></script><script src="/_next/static/chunks/b706f4b1-2831010e2dd2a749.js" async=""></script><script src="/_next/static/chunks/73dfd616-512978e649b76761.js" async=""></script><script src="/_next/static/chunks/963-4dffbac8d6a25e78.js" async=""></script><script src="/_next/static/chunks/679-d1a6a81af7b7551a.js" async=""></script><script src="/_next/static/chunks/app/layout-725688826163538f.js" async=""></script><script src="/_next/static/chunks/app/error-b5faafca2308edb7.js" async=""></script><script src="/_next/static/chunks/app/simple-coin/%5Bid%5D/page-180348f7e7a038cd.js" async=""></script><title>블록체인 &amp; 암호화폐 원리와 simple coin 구현 가이드 | JongMin Chae</title><meta name="description" content="JongMin Chae 개인 블록"/><link rel="icon" href="/images/spyglass.png"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="relative size-full"><header class="fixed top-0 z-50 flex h-12 w-full items-center border-gray-200 bg-white/95 pl-10 backdrop-blur-sm"><div class="flex items-center gap-2"><a href="/"><span>JongMin Chae</span></a><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="size-3" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M0 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm5-1v12h9a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM4 2H2a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h2z"></path></svg></div></header><div dir="ltr" class="relative overflow-hidden" style="position:relative;--radix-scroll-area-corner-width:0px;--radix-scroll-area-corner-height:0px"><style>[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}</style><div data-radix-scroll-area-viewport="" class="size-full rounded-[inherit]" style="overflow-x:hidden;overflow-y:hidden"><div style="min-width:100%;display:table"><main class="size-full transition-all duration-300 ease-out pl-0 overflow-x-hidden pt-12"><div class="mx-auto max-w-6xl p-8"><article class="prose !max-w-full"><h1>Simple mempool</h1>
<p>블록을 채굴하는 채굴자만 거래할 수 있다면 코인을 거래하기가 매우 힘들겠죠. 이번에는 블록에 추가되지 않은 트렌잭션을 보관하는 기능을 구현합니다. 비트코인에서는 이러한 트랜잭션을 보관하는 장소를 mempool이라고 부릅니다.</p>
<p>일반적으로 누군가가 트랜잭션을 블록체인에 포함시키고자 할 때(= 어떤 주소로 코인을 보내고자 할 때) 그 트랜잭션을 네트워크에 전파합니다. 이후 어떤 노드가 그 블록을 채굴했을 때, 블록에 넣어주는 방식입니다.</p>
<p>따라서 노드들이 서로 통신할 때는 두 가지 종류의 데이터를 공유하게 됩니다:</p>
<ol>
<li>블록체인 (= 블록과 그 안에 포함된 트랜잭션들)</li>
<li>mempool (= 아직 블록체인에 포함되지 않은 트랜잭션들)</li>
</ol>
<pre><code class="language-ts">let mempool: Transaction[] = []
</code></pre>
<p>새로운 엔드포인트를 추가합니다: <code>POST /sendTransaction</code>
이 메서드는 기존 지갑 기능을 기반으로 새로운 트랜잭션을 생성하여 mempool에 추가하고 네트워크로 전파합니다.</p>
<pre><code class="language-ts">app.post(&#x27;/sendTransaction&#x27;, (req, res) =&gt; {
  try {
    const address = req.body.address
    const amount = req.body.amount

    if (address === undefined || amount === undefined) {
      throw Error(&#x27;invalid address or amount&#x27;)
    }
    const tx = sendTransaction(address, amount)
    broadcastMempool()
    res.send(tx)
  } catch (e) {
    if (e instanceof Error) {
      console.log(e.message)
      res.status(400).send(e.message)
    } else {
      console.log(e)
      res.status(400).send(&#x27;unknown error&#x27;)
    }
  }
})
</code></pre>
<h2>트랜잭션 생성</h2>
<p>트랜잭션을 생성하는 과정은 이전과 동일합니다. 단지, 이번에는 바로 블록을 채굴해서 추가하지 않고, 생성된 트랜잭션을 mempool에 추가g합니다</p>
<pre><code class="language-ts">const sendTransaction = (address: string, amount: number): Transaction =&gt; {
  const tx: Transaction = createTransaction(
    address,
    amount,
    getPrivateFromWallet(),
    getUnspentTxOuts(),
    getTransactionPool(),
  )
  addToTransactionPool(tx, getUnspentTxOuts())
  return tx
}
</code></pre>
<h2>브로드캐스팅 (Broadcasting)</h2>
<p>미확인 트랜잭션의 핵심은 네트워크 전체로 전파되고, 결국 어떤 노드가 블록을 채굴하여 그 트랜잭션을 담아준다는 점입니다. 이를 처리하기 위해 미확인 트랜잭션 네트워킹에 대해 다음과 같은 간단한 규칙이 있어야 합니다:</p>
<ol>
<li>노드가 이전에 본 적 없는 트랜잭션을 받으면, 전체 mempool를 모든 피어에게 전파합니다.</li>
<li>노드가 다른 노드에 처음 연결될 때, 상대 노드의 mempool를 요청(query)합니다.</li>
</ol>
<p>이를 위해 두 가지 새로운 MessageType을 추가합니다:</p>
<pre><code class="language-ts">enum MessageType {
  QUERY_LATEST = 0, //최신 블록 요청
  QUERY_ALL = 1, // 전체 블록 요청
  RESPONSE_BLOCKCHAIN = 2, // 블록 응답
  QUERY_MEMPOOL = 3, // mempool 요청
  RESPONSE_MEMPOOL = 4, // mempool 응답
}
</code></pre>
<p>노드가 트랜잭션을 받았을 때 트랜잭션이 유효한지 검사하고 이전에 없던 거래인지 검사한 후에 mempool에 추가합니다. 만약 추가하는 데 성공했다면, 또다시 mempool를 모든 피어에게 전파합니다.</p>
<p><img alt=""/></p>
<h2>트랜잭션 검증</h2>
<p>트랜잭션을 mempool에 추가하기 전에 반드시 검증해야 합니다. 기존의 모든 트랜잭션 검증 규칙이 적용됩니다. 예를 들어, 트랜잭션은 올바른 형식을 가져야 하며, 서명이 유효해야 합니다.</p>
<p>그리고 새로운 규칙을 하나 추가해야 합니다.
트랜잭션의 인풋 중 하나라도 이미 기존 트랜잭션 풀에 존재한다면 그 트랜잭션은 풀에 추가될 수 없습니다.</p>
<pre><code class="language-ts">const isValidTxForMempool = (
  tx: Transaction,
  aMempool: Transaction[],
): boolean =&gt; {
  const txPoolIns: TxIn[] = getTxPoolIns(aMempool)

  for (const txIn of tx.txIns) {
    if (
      txPoolIns.some(
        (poolIn) =&gt;
          txIn.txOutId === poolIn.txOutId &amp;&amp;
          txIn.txOutIndex === poolIn.txOutIndex,
      )
    ) {
      console.log(&#x27;txIn already found in the txPool&#x27;)
      return false
    }
  }
  return true
}
</code></pre>
<p><img alt=""/></p>
<h2>mempool에서 블록체인으로</h2>
<p>노드가 블록 채굴하면 mempool에 있던 트랜잭션들을 새로운 블록 후보에 포함시킵니다.</p>
<p>트랜잭션들은 풀에 추가되기 전에 이미 검증되었으므로, 이 시점에서는 별도의 추가 검증을 수행하지 않습니다.</p>
<pre><code class="language-ts">const generateBlock = () =&gt; {
  const coinbaseTx: Transaction = getCoinbaseTransaction(
    getPublicFromWallet(),
    getLatestBlock().index + 1,
  )
  const blockData: Transaction[] = [coinbaseTx, ...getMempool()]
  return generateRawBlock(blockData)
}
</code></pre>
<h2>mempool 업데이트</h2>
<p>새로운 트랜잭션이 포함된 블록이 채굴될 때마다 반드시 mempool을 다시 검증해야 합니다. 새로운 블록에 포함된 트랜잭션으로 인해 트랜잭션 풀에 있는 일부 트랜잭션이 유효하지 않게 될 수 있기 때문입니다. 예를 들어:</p>
<ul>
<li>풀에 있던 트랜잭션이 (자신의 노드 또는 다른 노드에 의해) 채굴된 경우</li>
<li>확인되지 않은 트랜잭션이 참조하는 미사용 트랜잭션 출력(UTXO)이 다른 트랜잭션에 의해 사용된 경우</li>
</ul>
<p>트랜잭션 풀은 아래 코드로 업데이트되며, 현재 미사용 트랜잭션 출력(UTXO)만 알면 트랜잭션을 풀에서 제거해야 하는지 여부를 판단할 수 있습니다.</p>
<pre><code class="language-ts">const updateMempool = (unspentTxOuts: UnspentTxOut[]) =&gt; {
  const validTxs = mempool.filter((tx) =&gt;
    tx.txIns.every((txIn) =&gt; hasTxInUnspentTxOuts(txIn, unspentTxOuts)),
  )

  if (validTxs.length &lt; mempool.length) {
    const validTxSet = new Set(validTxs)
    const invalidTxs = mempool.filter((tx) =&gt; !validTxSet.has(tx))
    console.log(
      &#x27;removing the following transactions from mempool: %s&#x27;,
      JSON.stringify(invalidTxs),
    )
    mempool = validTxs
  }
}
</code></pre>
<p><img alt=""/></p>
<h2>다음 챕터</h2>
<p>이제 simple-coin을 쉽게 체험해보기 위해 도커를 설정하고 SPA 웹도 만들어 UI로 확인해보겠습니다.</p></article><div class="mt-12 flex items-center justify-between border-t pt-8"><a class="flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50" href="/simple-coin/wallet/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left size-4"><path d="m15 18-6-6 6-6"></path></svg>이전 아티클</a><div class="text-sm text-gray-500">6<!-- --> / <!-- -->7</div><a class="flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50" href="/simple-coin/spa/">다음 아티클<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right size-4"><path d="m9 18 6-6-6-6"></path></svg></a></div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></main></div></div></div><script src="/_next/static/chunks/webpack-2d2dc68beef0c482.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"2:\"$Sreact.fragment\"\n3:I[4752,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"679\",\"static/chunks/679-d1a6a81af7b7551a.js\",\"177\",\"static/chunks/app/layout-725688826163538f.js\"],\"SidebarProvider\"]\n4:I[9474,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"679\",\"static/chunks/679-d1a6a81af7b7551a.js\",\"177\",\"static/chunks/app/layout-725688826163538f.js\"],\"default\"]\n5:I[622,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"679\",\"static/chunks/679-d1a6a81af7b7551a.js\",\"177\",\"static/chunks/app/layout-725688826163538f.js\"],\"default\"]\n6:I[4752,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"679\",\"static/chunks/679-d1a6a81af7b7551a.js\",\"177\",\"static/chunks/app/layout-725688826163538f.js\"],\"Main\"]\n7:I[7059,[],\"\"]\n8:I[3333,[\"39\",\"static/chunks/app/error-b5faafca2308edb7.js\"],\"default\"]\n9:I[646,[],\"\"]\nb:I[3713,[],\"OutletBoundary\"]\nd:I[3713,[],\"MetadataBoundary\"]\nf:I[3713,[],\"ViewportBoundary\"]\n11:I[9359,[],\"\"]\n1:HL[\"/_next/static/css/2e677674121e02c0.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"gfNoNQW0gEMWLFXPuxaxo\",\"p\":\"\",\"c\":[\"\",\"simple-coin\",\"mempool\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"simple-coin\",{\"children\":[[\"id\",\"mempool\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$2\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/2e677674121e02c0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"__className_fde3a9 size-full\",\"children\":[\"$\",\"body\",null,{\"className\":\"relative size-full\",\"children\":[\"$\",\"$L3\",null,{\"children\":[[\"$\",\"header\",null,{\"className\":\"fixed top-0 z-50 flex h-12 w-full items-center border-gray-200 bg-white/95 pl-10 backdrop-blur-sm\",\"children\":[\"$\",\"$L4\",null,{\"children\":[\"$\",\"span\",null,{\"children\":\"JongMin Chae\"}]}]}],[\"$\",\"$L5\",null,{}],[\"$\",\"$L6\",null,{\"className\":\"overflow-x-hidden pt-12\",\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$8\",\"errorStyles\":[],\"errorScripts\":[],\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]}]]}],{\"children\":[\"simple-coin\",[\"$\",\"$2\",\"c\",{\"children\":[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"simple-coin\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"mempool\",\"d\"],[\"$\",\"$2\",\"c\",{\"children\":[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"simple-coin\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$2\",\"c\",{\"children\":[\"$La\",null,[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}]]}],{},null]},null]},null]},null],[\"$\",\"$2\",\"h\",{\"children\":[null,[\"$\",\"$2\",\"d_HeIOiU0rW1MvI9k_lmv\",{\"children\":[[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}],[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}]]}]]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:I[4963,[\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"713\",\"static/chunks/app/simple-coin/%5Bid%5D/page-180348f7e7a038cd.js\"],\"\"]\n13:I[4931,[\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"713\",\"static/chunks/app/simple-coin/%5Bid%5D/page-180348f7e7a038cd.js\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl p-8\",\"children\":[[\"$\",\"article\",null,{\"className\":\"prose !max-w-full\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"Simple mempool\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"블록을 채굴하는 채굴자만 거래할 수 있다면 코인을 거래하기가 매우 힘들겠죠. 이번에는 블록에 추가되지 않은 트렌잭션을 보관하는 기능을 구현합니다. 비트코인에서는 이러한 트랜잭션을 보관하는 장소를 mempool이라고 부릅니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"일반적으로 누군가가 트랜잭션을 블록체인에 포함시키고자 할 때(= 어떤 주소로 코인을 보내고자 할 때) 그 트랜잭션을 네트워크에 전파합니다. 이후 어떤 노드가 그 블록을 채굴했을 때, 블록에 넣어주는 방식입니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"따라서 노드들이 서로 통신할 때는 두 가지 종류의 데이터를 공유하게 됩니다:\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"블록체인 (= 블록과 그 안에 포함된 트랜잭션들)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"mempool (= 아직 블록체인에 포함되지 않은 트랜잭션들)\"}],\"\\n\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"let mempool: Transaction[] = []\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"새로운 엔드포인트를 추가합니다: \",[\"$\",\"code\",null,{\"children\":\"POST /sendTransaction\"}],\"\\r\\n이 메서드는 기존 지갑 기능을 기반으로 새로운 트랜잭션을 생성하여 mempool에 추가하고 네트워크로 전파합니다.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"app.post('/sendTransaction', (req, res) =\u003e {\\r\\n  try {\\r\\n    const address = req.body.address\\r\\n    const amount = req.body.amount\\r\\n\\r\\n    if (address === undefined || amount === undefined) {\\r\\n      throw Error('invalid address or amount')\\r\\n    }\\r\\n    const tx = sendTransaction(address, amount)\\r\\n    broadcastMempool()\\r\\n    res.send(tx)\\r\\n  } catch (e) {\\r\\n    if (e instanceof Error) {\\r\\n      console.log(e.message)\\r\\n      res.status(400).send(e.message)\\r\\n    } else {\\r\\n      console.log(e)\\r\\n      res.status(400).send('unknown error')\\r\\n    }\\r\\n  }\\r\\n})\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"트랜잭션 생성\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"트랜잭션을 생성하는 과정은 이전과 동일합니다. 단지, 이번에는 바로 블록을 채굴해서 추가하지 않고, 생성된 트랜잭션을 mempool에 추가g합니다\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const sendTransaction = (address: string, amount: number): Transaction =\u003e {\\r\\n  const tx: Transaction = createTransaction(\\r\\n    address,\\r\\n    amount,\\r\\n    getPrivateFromWallet(),\\r\\n    getUnspentTxOuts(),\\r\\n    getTransactionPool(),\\r\\n  )\\r\\n  addToTransactionPool(tx, getUnspentTxOuts())\\r\\n  return tx\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"브로드캐스팅 (Broadcasting)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"미확인 트랜잭션의 핵심은 네트워크 전체로 전파되고, 결국 어떤 노드가 블록을 채굴하여 그 트랜잭션을 담아준다는 점입니다. 이를 처리하기 위해 미확인 트랜잭션 네트워킹에 대해 다음과 같은 간단한 규칙이 있어야 합니다:\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"노드가 이전에 본 적 없는 트랜잭션을 받으면, 전체 mempool를 모든 피어에게 전파합니다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"노드가 다른 노드에 처음 연결될 때, 상대 노드의 mempool를 요청(query)합니다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이를 위해 두 가지 새로운 MessageType을 추가합니다:\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"enum MessageType {\\r\\n  QUERY_LATEST = 0, //최신 블록 요청\\r\\n  QUERY_ALL = 1, // 전체 블록 요청\\r\\n  RESPONSE_BLOCKCHAIN = 2, // 블록 응답\\r\\n  QUERY_MEMPOOL = 3, // mempool 요청\\r\\n  RESPONSE_MEMPOOL = 4, // mempool 응답\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"노드가 트랜잭션을 받았을 때 트랜잭션이 유효한지 검사하고 이전에 없던 거래인지 검사한 후에 mempool에 추가합니다. 만약 추가하는 데 성공했다면, 또다시 mempool를 모든 피어에게 전파합니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"트랜잭션 검증\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"트랜잭션을 mempool에 추가하기 전에 반드시 검증해야 합니다. 기존의 모든 트랜잭션 검증 규칙이 적용됩니다. 예를 들어, 트랜잭션은 올바른 형식을 가져야 하며, 서명이 유효해야 합니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"그리고 새로운 규칙을 하나 추가해야 합니다.\\r\\n트랜잭션의 인풋 중 하나라도 이미 기존 트랜잭션 풀에 존재한다면 그 트랜잭션은 풀에 추가될 수 없습니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const isValidTxForMempool = (\\r\\n  tx: Transaction,\\r\\n  aMempool: Transaction[],\\r\\n): boolean =\u003e {\\r\\n  const txPoolIns: TxIn[] = getTxPoolIns(aMempool)\\r\\n\\r\\n  for (const txIn of tx.txIns) {\\r\\n    if (\\r\\n      txPoolIns.some(\\r\\n        (poolIn) =\u003e\\r\\n          txIn.txOutId === poolIn.txOutId \u0026\u0026\\r\\n          txIn.txOutIndex === poolIn.txOutIndex,\\r\\n      )\\r\\n    ) {\\r\\n      console.log('txIn already found in the txPool')\\r\\n      return false\\r\\n    }\\r\\n  }\\r\\n  return true\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"mempool에서 블록체인으로\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"노드가 블록 채굴하면 mempool에 있던 트랜잭션들을 새로운 블록 후보에 포함시킵니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"트랜잭션들은 풀에 추가되기 전에 이미 검증되었으므로, 이 시점에서는 별도의 추가 검증을 수행하지 않습니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const generateBlock = () =\u003e {\\r\\n  const coinbaseTx: Transaction = getCoinbaseTransaction(\\r\\n    getPublicFromWallet(),\\r\\n    getLatestBlock().index + 1,\\r\\n  )\\r\\n  const blockData: Transaction[] = [coinbaseTx, ...getMempool()]\\r\\n  return generateRawBlock(blockData)\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"mempool 업데이트\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"새로운 트랜잭션이 포함된 블록이 채굴될 때마다 반드시 mempool을 다시 검증해야 합니다. 새로운 블록에 포함된 트랜잭션으로 인해 트랜잭션 풀에 있는 일부 트랜잭션이 유효하지 않게 될 수 있기 때문입니다. 예를 들어:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"풀에 있던 트랜잭션이 (자신의 노드 또는 다른 노드에 의해) 채굴된 경우\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"확인되지 않은 트랜잭션이 참조하는 미사용 트랜잭션 출력(UTXO)이 다른 트랜잭션에 의해 사용된 경우\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"트랜잭션 풀은 아래 코드로 업데이트되며, 현재 미사용 트랜잭션 출력(UTXO)만 알면 트랜잭션을 풀에서 제거해야 하는지 여부를 판단할 수 있습니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const updateMempool = (unspentTxOuts: UnspentTxOut[]) =\u003e {\\r\\n  const validTxs = mempool.filter((tx) =\u003e\\r\\n    tx.txIns.every((txIn) =\u003e hasTxInUnspentTxOuts(txIn, unspentTxOuts)),\\r\\n  )\\r\\n\\r\\n  if (validTxs.length \u003c mempool.length) {\\r\\n    const validTxSet = new Set(validTxs)\\r\\n    const invalidTxs = mempool.filter((tx) =\u003e !validTxSet.has(tx))\\r\\n    console.log(\\r\\n      'removing the following transactions from mempool: %s',\\r\\n      JSON.stringify(invalidTxs),\\r\\n    )\\r\\n    mempool = validTxs\\r\\n  }\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"다음 챕터\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이제 simple-coin을 쉽게 체험해보기 위해 도커를 설정하고 SPA 웹도 만들어 UI로 확인해보겠습니다.\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-12 flex items-center justify-between border-t pt-8\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/simple-coin/wallet\",\"className\":\"flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-chevron-left size-4\",\"children\":[[\"$\",\"path\",\"1wnfg3\",{\"d\":\"m15 18-6-6 6-6\"}],\"$undefined\"]}],\"이전 아티클\"]}],[\"$\",\"div\",null,{\"className\":\"text-sm text-gray-500\",\"children\":[6,\" / \",7]}],[\"$\",\"$L12\",null,{\"href\":\"/simple-coin/spa\",\"className\":\"flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50\",\"children\":[\"다음 아티클\",[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-chevron-right size-4\",\"children\":[[\"$\",\"path\",\"mthhwq\",{\"d\":\"m9 18 6-6-6-6\"}],\"$undefined\"]}]]}]]}]]}],[\"$\",\"$L13\",null,{}]]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\ne:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"블록체인 \u0026 암호화폐 원리와 simple coin 구현 가이드 | JongMin Chae\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"JongMin Chae 개인 블록\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/images/spyglass.png\"}]]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script></body></html>