<!DOCTYPE html><html lang="ko" class="__className_fde3a9 size-full"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/0c670e58-d279-4307-9d4b-3af44d0549da"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/c4684a48-143c-47c8-98d6-a7ef5397e877"/><link rel="stylesheet" href="/_next/static/css/aa5c0cfdd8dfd8bd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-2d2dc68beef0c482.js"/><script src="/_next/static/chunks/80433fe4-e24eaad93a1cfb9d.js" async=""></script><script src="/_next/static/chunks/367-0ec4dc94cb811371.js" async=""></script><script src="/_next/static/chunks/main-app-f1b4d9826ef8e891.js" async=""></script><script src="/_next/static/chunks/dd507964-94e7a1153960be03.js" async=""></script><script src="/_next/static/chunks/b706f4b1-2831010e2dd2a749.js" async=""></script><script src="/_next/static/chunks/73dfd616-512978e649b76761.js" async=""></script><script src="/_next/static/chunks/963-4dffbac8d6a25e78.js" async=""></script><script src="/_next/static/chunks/861-a604e88ff96e4e5b.js" async=""></script><script src="/_next/static/chunks/app/layout-a78bd4d9959768fe.js" async=""></script><script src="/_next/static/chunks/app/error-b5faafca2308edb7.js" async=""></script><script src="/_next/static/chunks/app/simple-coin/%5Bid%5D/page-180348f7e7a038cd.js" async=""></script><title>블록체인 &amp; 암호화폐 원리와 simple coin 구현 가이드 | Bit겐슈타인</title><meta name="description" content="Bit겐슈타인 개인 블록"/><link rel="icon" href="/images/spyglass.png"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="relative size-full"><header class="fixed top-0 z-50 flex h-12 w-full items-center border-gray-200 bg-white/95 pl-10 backdrop-blur-sm"><div class="flex items-center gap-2"><a href="/"><span>JongMin Chae</span></a><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" class="size-3" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M0 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm5-1v12h9a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM4 2H2a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h2z"></path></svg></div></header><div class="overflow-hidden"><main class="size-full transition-all duration-300 ease-out pl-0 overflow-x-hidden pt-12"><div class="mx-auto w-full max-w-6xl p-8"><article class="prose !max-w-full"><h1>Simple Wallet</h1>
<p>지갑은 사용자를 위해 추상적인 인터페이스를 제공해야 합니다. 사용자는 다음 작업을 수행할 수 있어야 합니다.</p>
<ul>
<li>새로운 지갑 생성(=이 경우, 개인 키)</li>
<li>지갑 잔액 조회</li>
<li>다른 주소로 코인 전송</li>
</ul>
<p>지갑이 있으면 사용자는 트랜잭션 입력, 출력의 작동 방식을 이해하지 않아도 다른 주소로 코인을 보내고, 다른 사람들의 코인을 받을 수 있습니다.</p>
<h2>개인 키 생성 및 저장</h2>
<p>simple-coin에서는 가장 간단한 방법으로 지갑을 생성하고 관리합니다. 암호화되지 않은 개인 키를 node/wallet/private_key 파일에 생성합니다.</p>
<pre><code class="language-typescript">const ec = new elliptic.ec(&#x27;secp256k1&#x27;)

const privateKeyLocation = &#x27;node/wallet/private_key&#x27;

const generatePrivateKey = (): string =&gt; {
  const keyPair = ec.genKeyPair()
  const privateKey = keyPair.getPrivate()
  return privateKey.toString(16)
}

const initWallet = () =&gt; {
  if (existsSync(privateKeyLocation)) {
    return
  }

  const dir = dirname(privateKeyLocation)
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true })
  }

  const newPrivateKey = generatePrivateKey()
  writeFileSync(privateKeyLocation, newPrivateKey)
}
</code></pre>
<p>앞서 언급했듯이, 공개 키(=주소)는 개인 키로부터 계산될 수 있습니다.</p>
<pre><code class="language-typescript">const getPublicFromWallet = (): string =&gt; {
  const privateKey = getPrivateFromWallet()
  const key = ec.keyFromPrivate(privateKey, &#x27;hex&#x27;)
  return key.getPublic().encode(&#x27;hex&#x27;, false)
}
</code></pre>
<p>개인 키를 암호화되지 않은 형식으로 저장하는 것은 매우 위험합니다. simple-coin에서는 최대한 단순하게 유지하기 위해 이 방법을 사용했습니다. 또한, 이 지갑은 단 하나의 개인 키만 지원합니다. 새로운 공개 주소를 얻으려면 새 지갑을 생성해야 합니다.</p>
<h2>잔액 확인</h2>
<p>블록체인에서 코인을 소유한다는 것은 본인이 소유한 공개 키를 가지고 있는 사용되지 않은 트랜잭션 출력(uTxO) 목록을 가지고 있다는 것을 의미합니다. 즉 잔고를 확인하기 위해서는 해당 공개 키(주소)를 가진 모든 사용되지 않은 트랜잭션 아웃풋을 합산하기만 하면 됩니다.</p>
<pre><code class="language-typescript">const getBalance = (address: string, unspentTxOuts: UnspentTxOut[]): number =&gt; {
  return unspentTxOuts
    .filter((uTxO) =&gt; uTxO.address === address)
    .reduce((sum, uTxO) =&gt; sum + uTxO.amount, 0)
}
</code></pre>
<p>코드에서 볼 수 있듯이, 주소의 잔액을 조회하는 데 개인 키는 필요하지 않습니다. 따라서 누구나 특정 주소의 잔액을 확인할 수 있습니다.</p>
<h2>코인 전송</h2>
<p>코인을 전송할 때, 사용자는 트랜잭션 입력 및 출력의 개념을 알지 못합니다. 종민이가 상규에게 20코인을 보내고 싶은 상황이라고 해봅시다. 종민이가 30코인의 잔액을 가지고 있지만 이것이 단 하나의 출력(uTxO)일 경우 어떻게 할까요?</p>
<p>하나의 트랜잭션 출력은 항상 전부 소비되어야 하기 때문에 상규의 주소로 20 비트코인을 보내고, 10 코인은 다시 사용자 종민에게 돌려보내는 트랜잭션을 만들어야 합니다.</p>
<p><img src="https://github.com/user-attachments/assets/0c670e58-d279-4307-9d4b-3af44d0549da" alt=""/></p>
<p>조금 더 복잡한 트랜잭션 시나리오를 살펴봅시다:</p>
<ul>
<li>종민이는 처음에 0코인을 가지고 있습니다.</li>
<li>종민이가 각각 20코인, 25코인짜리 트랜잭션 2개를 받습니다.</li>
<li>종민이는 상규에게 40코인을 보내고 싶어 합니다.</li>
</ul>
<p>이 경우, 20코인, 25코인 출력을 모두를 사용해야 하며, 새로운 트랜잭션의 출력은 상규에게 40코인, 그리고 종민에게 다시 5코인을 보냅니다.</p>
<p><img src="https://github.com/user-attachments/assets/c4684a48-143c-47c8-98d6-a7ef5397e877" alt=""/></p>
<h2>구현</h2>
<h3>포함해야 하는 아웃풋과 남는 금액을 계산</h3>
<p><code>leftOverAmount</code>는 다시 돌려보낼 금액을 의미합니다.</p>
<pre><code class="language-ts">const findTxOutsForAmount = (
  amount: number,
  myUnspentTxOuts: UnspentTxOut[],
) =&gt; {
  let currentAmount = 0
  const includedUnspentTxOuts: UnspentTxOut[] = []
  for (const myUnspentTxOut of myUnspentTxOuts) {
    includedUnspentTxOuts.push(myUnspentTxOut)
    currentAmount = currentAmount + myUnspentTxOut.amount
    if (currentAmount &gt;= amount) {
      const leftOverAmount = currentAmount - amount

      return { includedUnspentTxOuts, leftOverAmount }
    }
  }
  const errorMessage =
    &#x27;Cannot create transaction from the available unspent transaction outputs.&#x27; +
    &#x27; Required amount:&#x27; +
    amount +
    &#x27;. Available unspentTxOuts:&#x27; +
    JSON.stringify(myUnspentTxOuts)
  throw Error(errorMessage)
}
</code></pre>
<h3>아웃풋 목록 생성</h3>
<p>다음으로, 트랜잭션의 두 개 출력을 생성합니다:</p>
<ul>
<li>하나는 코인을 받는 사람(receiver)을 위한 출력</li>
<li>다른 하나는 <strong>leftOverAmount</strong>(거스름돈)을 위한 출력</li>
</ul>
<p>만약 txIns가 정확히 원하는 금액만큼의 값을 가진다면(<code>leftOverAmount === 0</code>), “거스름돈” 트랜잭션은 생성하지 않습니다.</p>
<pre><code class="language-ts">const createTxOuts = (
  receiverAddress: string,
  myAddress: string,
  amount: number,
  leftOverAmount: number,
) =&gt; {
  const txOut1 = new TxOut(receiverAddress, amount)
  if (leftOverAmount === 0) {
    return [txOut1]
  } else {
    const leftOverTx = new TxOut(myAddress, leftOverAmount)
    return [txOut1, leftOverTx]
  }
}
</code></pre>
<h3>인풋 목록 생성</h3>
<p>미사용 트랜잭션 출력(UTXO) 목록을 가지고 있으므로, 이를 이용해 트랜잭션의 txIns를 생성합니다.</p>
<pre><code class="language-ts">const { includedUnspentTxOuts, leftOverAmount } = findTxOutsForAmount(
  amount,
  myUnspentTxOuts,
)

const toUnsignedTxIn = (unspentTxOut: UnspentTxOut) =&gt; {
  const txIn = new TxIn(unspentTxOut.txOutId, unspentTxOut.txOutIndex, &#x27;&#x27;)
  return txIn
}

const unsignedTxIns: TxIn[] = includedUnspentTxOuts.map(toUnsignedTxIn)
</code></pre>
<h3>트랜잭션 ID를 계산하고 txIns에 서명</h3>
<pre><code class="language-ts">const unsignedTxIns: TxIn[] = includedUnspentTxOuts.map(toUnsignedTxIn)

const tx = new Transaction(
  &#x27;&#x27;,
  unsignedTxIns,
  createTxOuts(receiverAddress, myAddress, amount, leftOverAmount),
)
tx.id = getTransactionId(tx)

tx.txIns = tx.txIns.map((txIn: TxIn, index: number) =&gt; {
  txIn.signature = signTxIn(tx, index, privateKey, unspentTxOuts)
  return txIn
})
</code></pre>
<h2>지갑 사용을 위한 HTTP</h2>
<p>사용자가 주소와 금액만 전달하면 트랜잭션을 생성하고 블록에 담아 체인에 추가합니다. 추가되면 네트워크로 전파합니다.</p>
<pre><code class="language-ts">app.post(&#x27;/mineTransaction&#x27;, (req, res) =&gt; {
  const address = req.body.address
  const amount = req.body.amount
  try {
    const newBlock = generateBlockWithTransaction(address, amount)
    if (newBlock === null) {
      res.status(400).send(&#x27;could not generate block&#x27;)
    } else {
      broadcastLatest()
      res.send(newBlock)
    }
  } catch (e) {
    if (e instanceof Error) {
      res.status(400).send(e.message)
    } else {
      res.status(400).send(&#x27;unknown error&#x27;)
    }
  }
})
</code></pre>
<p>자신의 주소와 잔고를 확인합니다.</p>
<pre><code class="language-ts">app.get(&#x27;/balance&#x27;, (req, res) =&gt; {
  const balance: number = getAccountBalance()
  res.send({ balance: balance })
})

app.get(&#x27;/address&#x27;, (req, res) =&gt; {
  const address: string = getPublicFromWallet()
  res.send({ address: address })
})
</code></pre>
<h2>다음 챕터</h2>
<p>지금까지는 거래를 블록체인에 올리기 위해서 무조건 블록을 채굴해야 합니다. 하지만 채굴자가 아닌 사람도 거래를 할 수 있어야 합니다. 이를 위해 mempool를 구현해야 합니다.</p></article><div class="mt-12 flex items-center justify-between border-t pt-8"><a class="flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50" href="/simple-coin/transaction/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left size-4"><path d="m15 18-6-6 6-6"></path></svg>이전 아티클</a><div class="text-sm text-gray-500">5<!-- --> / <!-- -->8</div><a class="flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50" href="/simple-coin/mempool/">다음 아티클<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right size-4"><path d="m9 18 6-6-6-6"></path></svg></a></div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></main></div><script src="/_next/static/chunks/webpack-2d2dc68beef0c482.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"2:\"$Sreact.fragment\"\n3:I[4752,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"861\",\"static/chunks/861-a604e88ff96e4e5b.js\",\"177\",\"static/chunks/app/layout-a78bd4d9959768fe.js\"],\"SidebarProvider\"]\n4:I[9474,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"861\",\"static/chunks/861-a604e88ff96e4e5b.js\",\"177\",\"static/chunks/app/layout-a78bd4d9959768fe.js\"],\"default\"]\n5:I[622,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"861\",\"static/chunks/861-a604e88ff96e4e5b.js\",\"177\",\"static/chunks/app/layout-a78bd4d9959768fe.js\"],\"default\"]\n6:I[4752,[\"282\",\"static/chunks/dd507964-94e7a1153960be03.js\",\"533\",\"static/chunks/b706f4b1-2831010e2dd2a749.js\",\"692\",\"static/chunks/73dfd616-512978e649b76761.js\",\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"861\",\"static/chunks/861-a604e88ff96e4e5b.js\",\"177\",\"static/chunks/app/layout-a78bd4d9959768fe.js\"],\"Main\"]\n7:I[7059,[],\"\"]\n8:I[3333,[\"39\",\"static/chunks/app/error-b5faafca2308edb7.js\"],\"default\"]\n9:I[646,[],\"\"]\nb:I[3713,[],\"OutletBoundary\"]\nd:I[3713,[],\"MetadataBoundary\"]\nf:I[3713,[],\"ViewportBoundary\"]\n11:I[9359,[],\"\"]\n1:HL[\"/_next/static/css/aa5c0cfdd8dfd8bd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"D_U5t8q2CGt8CdET4kR36\",\"p\":\"\",\"c\":[\"\",\"simple-coin\",\"wallet\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"simple-coin\",{\"children\":[[\"id\",\"wallet\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$2\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/aa5c0cfdd8dfd8bd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"__className_fde3a9 size-full\",\"children\":[\"$\",\"body\",null,{\"className\":\"relative size-full\",\"children\":[\"$\",\"$L3\",null,{\"children\":[[\"$\",\"header\",null,{\"className\":\"fixed top-0 z-50 flex h-12 w-full items-center border-gray-200 bg-white/95 pl-10 backdrop-blur-sm\",\"children\":[\"$\",\"$L4\",null,{\"children\":[\"$\",\"span\",null,{\"children\":\"JongMin Chae\"}]}]}],[\"$\",\"$L5\",null,{}],[\"$\",\"$L6\",null,{\"className\":\"overflow-x-hidden pt-12\",\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$8\",\"errorStyles\":[],\"errorScripts\":[],\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]}]]}],{\"children\":[\"simple-coin\",[\"$\",\"$2\",\"c\",{\"children\":[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"simple-coin\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"wallet\",\"d\"],[\"$\",\"$2\",\"c\",{\"children\":[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"simple-coin\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$2\",\"c\",{\"children\":[\"$La\",null,[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}]]}],{},null]},null]},null]},null],[\"$\",\"$2\",\"h\",{\"children\":[null,[\"$\",\"$2\",\"tMpq6kH9m0VzIXmwbqlsc\",{\"children\":[[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}],[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}]]}]]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:I[4963,[\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"713\",\"static/chunks/app/simple-coin/%5Bid%5D/page-180348f7e7a038cd.js\"],\"\"]\n13:I[4931,[\"963\",\"static/chunks/963-4dffbac8d6a25e78.js\",\"713\",\"static/chunks/app/simple-coin/%5Bid%5D/page-180348f7e7a038cd.js\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-6xl p-8\",\"children\":[[\"$\",\"article\",null,{\"className\":\"prose !max-w-full\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"Simple Wallet\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"지갑은 사용자를 위해 추상적인 인터페이스를 제공해야 합니다. 사용자는 다음 작업을 수행할 수 있어야 합니다.\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"새로운 지갑 생성(=이 경우, 개인 키)\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"지갑 잔액 조회\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"다른 주소로 코인 전송\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"지갑이 있으면 사용자는 트랜잭션 입력, 출력의 작동 방식을 이해하지 않아도 다른 주소로 코인을 보내고, 다른 사람들의 코인을 받을 수 있습니다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"개인 키 생성 및 저장\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"simple-coin에서는 가장 간단한 방법으로 지갑을 생성하고 관리합니다. 암호화되지 않은 개인 키를 node/wallet/private_key 파일에 생성합니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"const ec = new elliptic.ec('secp256k1')\\r\\n\\r\\nconst privateKeyLocation = 'node/wallet/private_key'\\r\\n\\r\\nconst generatePrivateKey = (): string =\u003e {\\r\\n  const keyPair = ec.genKeyPair()\\r\\n  const privateKey = keyPair.getPrivate()\\r\\n  return privateKey.toString(16)\\r\\n}\\r\\n\\r\\nconst initWallet = () =\u003e {\\r\\n  if (existsSync(privateKeyLocation)) {\\r\\n    return\\r\\n  }\\r\\n\\r\\n  const dir = dirname(privateKeyLocation)\\r\\n  if (!existsSync(dir)) {\\r\\n    mkdirSync(dir, { recursive: true })\\r\\n  }\\r\\n\\r\\n  const newPrivateKey = generatePrivateKey()\\r\\n  writeFileSync(privateKeyLocation, newPrivateKey)\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"앞서 언급했듯이, 공개 키(=주소)는 개인 키로부터 계산될 수 있습니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"const getPublicFromWallet = (): string =\u003e {\\r\\n  const privateKey = getPrivateFromWallet()\\r\\n  const key = ec.keyFromPrivate(privateKey, 'hex')\\r\\n  return key.getPublic().encode('hex', false)\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"개인 키를 암호화되지 않은 형식으로 저장하는 것은 매우 위험합니다. simple-coin에서는 최대한 단순하게 유지하기 위해 이 방법을 사용했습니다. 또한, 이 지갑은 단 하나의 개인 키만 지원합니다. 새로운 공개 주소를 얻으려면 새 지갑을 생성해야 합니다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"잔액 확인\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"블록체인에서 코인을 소유한다는 것은 본인이 소유한 공개 키를 가지고 있는 사용되지 않은 트랜잭션 출력(uTxO) 목록을 가지고 있다는 것을 의미합니다. 즉 잔고를 확인하기 위해서는 해당 공개 키(주소)를 가진 모든 사용되지 않은 트랜잭션 아웃풋을 합산하기만 하면 됩니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-typescript\",\"children\":\"const getBalance = (address: string, unspentTxOuts: UnspentTxOut[]): number =\u003e {\\r\\n  return unspentTxOuts\\r\\n    .filter((uTxO) =\u003e uTxO.address === address)\\r\\n    .reduce((sum, uTxO) =\u003e sum + uTxO.amount, 0)\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"코드에서 볼 수 있듯이, 주소의 잔액을 조회하는 데 개인 키는 필요하지 않습니다. 따라서 누구나 특정 주소의 잔액을 확인할 수 있습니다.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"코인 전송\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"코인을 전송할 때, 사용자는 트랜잭션 입력 및 출력의 개념을 알지 못합니다. 종민이가 상규에게 20코인을 보내고 싶은 상황이라고 해봅시다. 종민이가 30코인의 잔액을 가지고 있지만 이것이 단 하나의 출력(uTxO)일 경우 어떻게 할까요?\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"하나의 트랜잭션 출력은 항상 전부 소비되어야 하기 때문에 상규의 주소로 20 비트코인을 보내고, 10 코인은 다시 사용자 종민에게 돌려보내는 트랜잭션을 만들어야 합니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"https://github.com/user-attachments/assets/0c670e58-d279-4307-9d4b-3af44d0549da\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"조금 더 복잡한 트랜잭션 시나리오를 살펴봅시다:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"종민이는 처음에 0코인을 가지고 있습니다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"종민이가 각각 20코인, 25코인짜리 트랜잭션 2개를 받습니다.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"종민이는 상규에게 40코인을 보내고 싶어 합니다.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이 경우, 20코인, 25코인 출력을 모두를 사용해야 하며, 새로운 트랜잭션의 출력은 상규에게 40코인, 그리고 종민에게 다시 5코인을 보냅니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"img\",null,{\"src\":\"https://github.com/user-attachments/assets/c4684a48-143c-47c8-98d6-a7ef5397e877\",\"alt\":\"\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"구현\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"포함해야 하는 아웃풋과 남는 금액을 계산\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"leftOverAmount\"}],\"는 다시 돌려보낼 금액을 의미합니다.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const findTxOutsForAmount = (\\r\\n  amount: number,\\r\\n  myUnspentTxOuts: UnspentTxOut[],\\r\\n) =\u003e {\\r\\n  let currentAmount = 0\\r\\n  const includedUnspentTxOuts: UnspentTxOut[] = []\\r\\n  for (const myUnspentTxOut of myUnspentTxOuts) {\\r\\n    includedUnspentTxOuts.push(myUnspentTxOut)\\r\\n    currentAmount = currentAmount + myUnspentTxOut.amount\\r\\n    if (currentAmount \u003e= amount) {\\r\\n      const leftOverAmount = currentAmount - amount\\r\\n\\r\\n      return { includedUnspentTxOuts, leftOverAmount }\\r\\n    }\\r\\n  }\\r\\n  const errorMessage =\\r\\n    'Cannot create transaction from the available unspent transaction outputs.' +\\r\\n    ' Required amount:' +\\r\\n    amount +\\r\\n    '. Available unspentTxOuts:' +\\r\\n    JSON.stringify(myUnspentTxOuts)\\r\\n  throw Error(errorMessage)\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"아웃풋 목록 생성\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"다음으로, 트랜잭션의 두 개 출력을 생성합니다:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"하나는 코인을 받는 사람(receiver)을 위한 출력\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"다른 하나는 \",[\"$\",\"strong\",null,{\"children\":\"leftOverAmount\"}],\"(거스름돈)을 위한 출력\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"만약 txIns가 정확히 원하는 금액만큼의 값을 가진다면(\",[\"$\",\"code\",null,{\"children\":\"leftOverAmount === 0\"}],\"), “거스름돈” 트랜잭션은 생성하지 않습니다.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const createTxOuts = (\\r\\n  receiverAddress: string,\\r\\n  myAddress: string,\\r\\n  amount: number,\\r\\n  leftOverAmount: number,\\r\\n) =\u003e {\\r\\n  const txOut1 = new TxOut(receiverAddress, amount)\\r\\n  if (leftOverAmount === 0) {\\r\\n    return [txOut1]\\r\\n  } else {\\r\\n    const leftOverTx = new TxOut(myAddress, leftOverAmount)\\r\\n    return [txOut1, leftOverTx]\\r\\n  }\\r\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"인풋 목록 생성\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"미사용 트랜잭션 출력(UTXO) 목록을 가지고 있으므로, 이를 이용해 트랜잭션의 txIns를 생성합니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const { includedUnspentTxOuts, leftOverAmount } = findTxOutsForAmount(\\r\\n  amount,\\r\\n  myUnspentTxOuts,\\r\\n)\\r\\n\\r\\nconst toUnsignedTxIn = (unspentTxOut: UnspentTxOut) =\u003e {\\r\\n  const txIn = new TxIn(unspentTxOut.txOutId, unspentTxOut.txOutIndex, '')\\r\\n  return txIn\\r\\n}\\r\\n\\r\\nconst unsignedTxIns: TxIn[] = includedUnspentTxOuts.map(toUnsignedTxIn)\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"트랜잭션 ID를 계산하고 txIns에 서명\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"const unsignedTxIns: TxIn[] = includedUnspentTxOuts.map(toUnsignedTxIn)\\r\\n\\r\\nconst tx = new Transaction(\\r\\n  '',\\r\\n  unsignedTxIns,\\r\\n  createTxOuts(receiverAddress, myAddress, amount, leftOverAmount),\\r\\n)\\r\\ntx.id = getTransactionId(tx)\\r\\n\\r\\ntx.txIns = tx.txIns.map((txIn: TxIn, index: number) =\u003e {\\r\\n  txIn.signature = signTxIn(tx, index, privateKey, unspentTxOuts)\\r\\n  return txIn\\r\\n})\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"지갑 사용을 위한 HTTP\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"사용자가 주소와 금액만 전달하면 트랜잭션을 생성하고 블록에 담아 체인에 추가합니다. 추가되면 네트워크로 전파합니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"app.post('/mineTransaction', (req, res) =\u003e {\\r\\n  const address = req.body.address\\r\\n  const amount = req.body.amount\\r\\n  try {\\r\\n    const newBlock = generateBlockWithTransaction(address, amount)\\r\\n    if (newBlock === null) {\\r\\n      res.status(400).send('could not generate block')\\r\\n    } else {\\r\\n      broadcastLatest()\\r\\n      res.send(newBlock)\\r\\n    }\\r\\n  } catch (e) {\\r\\n    if (e instanceof Error) {\\r\\n      res.status(400).send(e.message)\\r\\n    } else {\\r\\n      res.status(400).send('unknown error')\\r\\n    }\\r\\n  }\\r\\n})\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"자신의 주소와 잔고를 확인합니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts\",\"children\":\"app.get('/balance', (req, res) =\u003e {\\r\\n  const balance: number = getAccountBalance()\\r\\n  res.send({ balance: balance })\\r\\n})\\r\\n\\r\\napp.get('/address', (req, res) =\u003e {\\r\\n  const address: string = getPublicFromWallet()\\r\\n  res.send({ address: address })\\r\\n})\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"다음 챕터\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"지금까지는 거래를 블록체인에 올리기 위해서 무조건 블록을 채굴해야 합니다. 하지만 채굴자가 아닌 사람도 거래를 할 수 있어야 합니다. 이를 위해 mempool를 구현해야 합니다.\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-12 flex items-center justify-between border-t pt-8\",\"children\":[[\"$\",\"$L12\",null,{\"href\":\"/simple-coin/transaction\",\"className\":\"flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-chevron-left size-4\",\"children\":[[\"$\",\"path\",\"1wnfg3\",{\"d\":\"m15 18-6-6 6-6\"}],\"$undefined\"]}],\"이전 아티클\"]}],[\"$\",\"div\",null,{\"className\":\"text-sm text-gray-500\",\"children\":[5,\" / \",8]}],[\"$\",\"$L12\",null,{\"href\":\"/simple-coin/mempool\",\"className\":\"flex items-center gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50\",\"children\":[\"다음 아티클\",[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-chevron-right size-4\",\"children\":[[\"$\",\"path\",\"mthhwq\",{\"d\":\"m9 18 6-6-6-6\"}],\"$undefined\"]}]]}]]}]]}],[\"$\",\"$L13\",null,{}]]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\ne:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"블록체인 \u0026 암호화폐 원리와 simple coin 구현 가이드 | Bit겐슈타인\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Bit겐슈타인 개인 블록\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/images/spyglass.png\"}]]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script></body></html>